# Project Coding Guidelines

- Please follow camel casing for function and variable names
- Create reusable components in 
    - `app\core`

- follow [object property naming guidelines](object/object-property-names.md)
## Learn about angular module system

https://toddmotto.com/angular-modules-setters-getters/

## Use multiple namespaces (modules).  

You can use a separate namespace for every module/view/component if you want.  
Find an organization that best fits the project.  namespaces can depend on other namespaces.  
Even if duplications occur between namespaces, those objects will only be defined once in the DI context.


## Use Angular services
Prefer angular wrapper objects over native browser objects (window, location, setTimeout)
Use $window, $location, $timeout instead. Each has been created to protect the bindings and meta data generated by the angular compiler at runtime.

## Avoid global scope or storing anything on the window object
Do not store ANYTHING on the window object.  This is global space.  
   - exception: temporary storage until angular is bootstrapped and can copy the data into an angular constant or value within an angular module.
  
## Avoid JQuery  
Do not use JQuery.  Angular has an 'element' object that uses JQuery lite (and defers to JQuery if it is loaded prior to the angular lib).

## Avoid native event listeners
Do not use native events ( window.eventListener ).  Angular has it's own event pub/sub system [ $emit, $broadcast ]
Anything you do outside of angular comes with a cost of managing the data/events manually on every $digest cycle.


## Do not modify the DOM outside of a directive.  

## Avoid logic in the view.
Do not use excessive logic in markup. Angular markup will contain some logic (ng-repeat, ng-if, ng-hide, ng-show, ng-class, ng-switch), 
the trick is to limit the amount of logic in the view. Copy the logic to a method in a controller and expose that method to the view.

## Object Aliasing : pass by value or pass by reference

in service create a data storage attribute:

```
var model = {

 prop1: 'value',
 prop2: { propA: 'value' },
 prop3: [ 1, 2, 3]
};
```

in your controller create a local attribute to reference the service.model.
```
var vm.data = service.model;
```
Now, as long as you modify and assign values to properties within the model reference `vm.data` it will be reflected in the service and to any other controller or service that references that service.

On the other hand, if you create a value attribute on the controller that references a 'field' in a service, not an object, then you are assigning the value of that field, not a reference. Therefore
when you change the value of the attribute it will not be reflected in the service.

```
// controller
vm.prop1 = service.model.prop1;
```

```
// view
<input ng-model="vm.prop1">
```


## $Scope Soup

http://www.technofattie.com/2014/03/21/five-guidelines-for-avoiding-scope-soup-in-angular.html

    follow the 'controller as' syntax to limit $scope soup

    5. Don't Use Scope To Pass Data Around
    Scope can be a convenient way to pass data between two controllers, it might even feel a little ninja, but it will almost always end in tears and heavy drinking.

$scope is NOT THE MODEL.  $scope is a binding mechanism between the view and the controller.

controllers are NOT THE MODEL.  controllers expose data and functionality to the view.

controllers are not singletons.  Every request for a controller instantiates a brand new copy of the controller definition with it's own internal state. 
This can create a big problem if you instantiate a controller in a loop like ng-repeat, and each controller makes a call to load data...

services ARE singletons, therefore they are public to anyone who has access to their module space. 
As singletons services are created once and shared across all requests for that service, thus they are the perfect method to share data. 

## $scope pass by value or reference

when using $scope you have the problem of the object vs value.  If a value is stored on the $scope and referenced in the view:

`$scope.name='satnam';`

`<h1>{{name}}</h1>`

angular creates bindings to the myName attribute.  When you change that attribute withing the controller:

`$scope.name='satnam singh';`

you lose those bindings and you not have a whole new string object.

On the otherhand, if you use an object:

`$scope.data = { name: 'satnam', title: 'Developer' };`

`<h1>{{data.name}}</h1>`

and later in the controller you change the name:

`$scope.data.name = 'sam';`

you still have all the bindings for the data object and the UI will reflect the changes.


### controllerAs
The easiest was to avoid this is to use the 'controller as' syntax.

`<div ng-controller='myController as vm'>`

This is identical to doing:

`function myController() {
  $scope.vm = this;
}`

controllerAs automatically appends a reference to your controller to the underlying scope (even though you did not inject or reference it). 
Then in the view you simply reference all attributes and methods from the controller using the provided label

`<h1>{{vm.data.name}}</h1>`

(you can use any label you want, but a commonly used one is 'vm' for 'view model')
You do not have to worry about nested views or controllers as each controller still has it's own child scope, 
and that scope will have it's own controller label ('vm').  When referencing 'vm' in your view it will always 
look in the current child scope first.
Although this is a good argument for making more explicit labels if you are going to nest your scopes.

## Use Skinny Controllers

Keep controllers skinny.  Move all data manipulation logic into the service where the data lives. 
If the view needs to trigger a method the controller can expose that method as a wrapper to the service method.

### Making Skinny AngularJS Controllers
https://scotch.io/tutorials/making-skinny-angularjs-controllers

    AngularJS 2.0 does away with $scope as everything is bound to plain ES6 classes, so you might as well get used to not using $scope. There are other good reasons to forego $scope, such as removing the temptation to overuse $watch, $apply, $on, $parent, and other methods of $scope that can bloat your controller. Chances are, if you are using one of those methods, it can be deferred to a service. Opt for the Controller as syntax whenever possible, and remember, you can still inject $scope if you need to use one of its methods.

    Our controller should be almost completely agnostic as to how data is retrieved and sent, and should only be concerned with the general action of sending and retrieving data to and from the service.

### Make Code Reusable with AngularJS Services
http://ryanchenkie.com/angularjs-services/


### Service | Factor | Provider: 

http://tylermcginnis.com/angularjs-factory-vs-service-vs-provider/


### Re-Thinking Angular JS Controllers
https://toddmotto.com/rethinking-angular-js-controllers/



## Web Components

###  Use the Web Component Directive pattern.

   a single composable module that contains all the code, markup, styles and tests needed to display content to a web page.  
   These components can have dependencies on injectable 3rd party libs or components defined under client/common.
   
   Try to decompose an application into a collection of such composable units.  Each is easily testable and re-usable, even if they are custom and specific to your application.


#### Component based AngularJS Directives
https://www.airpair.com/angularjs/posts/component-based-angularjs-directives

#### Exploring the AngularJS 1.5 component() method
https://toddmotto.com/exploring-the-angular-1-5-component-method/


# Testing angular Web Components

https://puigcerber.com/2016/02/07/how-to-test-angular-1-5-components/

## Test Data

Create a 'test-data' angular module to contain constants for all unit tests.  
You can create multiple files to define test data, for which all will add to the 'test-data' module.
This will keep large chunks of test data outside of the source code making it easier to edit the test files, and to share test data across fixtures and modules.
In each test simply register access to the 'test-data' module `{ beforeEach(module('test-data')); }` and then inject the desired constants.  
If you will be modifying the constant data then use angular.copy(data) to make a copy/clone of the data first (in the beforeEach).




### One Way Data Binding

https://toddmotto.com/one-way-data-binding-in-angular-1-5/



### Wrap modules in IIFE and use named functions rather than anonymous

https://toddmotto.com/minimal-angular-module-syntax-approach-using-an-iife/

Prefer named functions to Anonymous functions

## Limit use of DOM based filters

https://toddmotto.com/use-controller-filters-to-prevent-digest-performance-issues/

    Filters in Angular massively contribute to slow performance, so let’s adopt a sensible way of doing things, which may take you an additional ten minute to code, but will dramatically enhance your application’s performance.

      filters in the DOM actually impacts our $digest cycles.




## Limit the size of your files.  
Compose large view from smaller web components.


## Learn about the route state machine

https://github.com/angular-ui/ui-router/wiki#alternative-ways-to-set-the-template



# Angular Style Guides

https://github.com/johnpapa/angular-styleguide


https://github.com/toddmotto/angular-styleguide


# Self Closing Tags

Not all tags in 
http://xahlee.info/js/html5_non-closing_tag.html

```
<area />
<base />
<br />
<col />
<command />
<embed />
<hr />
<img />
<input />
<keygen />
<link />
<meta />
<param />
<source />
<track />
<wbr />
```
Is the Ending Slash Optional?

- HTML5: the slash is optional.
- HTML4: the slash is technically invalid. However, it's accepted by W3C's HTML validator.
- XHTML: The slash is REQUIRED.



# block vs line tags

`<p>` is a block element and cannot contain another block level element

i.e
`<p> Something <div class='doh'> This is bad </div> to Do </p>`

# Style the browser console
https://developers.google.com/web/tools/chrome-devtools/console/console-write
